
> 还有问题！！！！！！！

### 今天题目：1345. 跳跃游戏 IV

难度：困难

给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。

每一步，你可以从下标 i 跳到下标：

i + 1 满足：i + 1 < arr.length
i - 1 满足：i - 1 >= 0
j 满足：arr[i] == arr[j] 且 i != j
请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。

注意：任何时候你都不能跳到数组外面。


示例 1：

输入：arr = [100,-23,-23,404,100,23,23,23,3,404]
输出：3
解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。

示例 2：

输入：arr = [7]
输出：0
解释：一开始就在最后一个元素处，所以你不需要跳跃。


示例 3：

输入：arr = [7,6,9,6,9,6,9,7]
输出：1
解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。

示例 4：

输入：arr = [6,1,9]
输出：2


示例 5：

输入：arr = [11,22,7,7,7,7,7,7,7,22,13]
输出：3
 

提示：

1 <= arr.length <= 5 * 10^4
-10^8 <= arr[i] <= 10^8

 

### 我的思路

1.  先处理非数组和单个元素数组
1.  清晰最终的目标是到达最后一个元素所用步数
1.  i的变化得分三种情况，i + 1、i - 1和j ，任何情况都可能是最快的
1.  首先扫一下整个数组，看最远的处有没有相等的，即j，如果有就移动，否则让i++
1.  需要同时满足两个数相等，且不是同一个数 
1.  往回走先不考虑


### 代码实现

```js
/**
* @param {number[]} arr
* @return {number}
*/
var minJumps = function (arr) {
    // 先处理非数组和单个元素数组
    if (Array.isArray(arr)) {
        var len = arr.length//数组长度
        if (len == 1) { return 0 }
        // 清晰最终的目标是到达最后一个元素所用步数
        // 首先下一步到达的元素小标，我们可以分三条支路，i + 1、i - 1和j 
        // 但是每条支路又会有支路，但是如果之前走过的，就说明这条支路走不通

        var count = 0;//步数
        for (var i = 0; i !== len - 1;) {//i !== len - 1表示走到最后一位了
            //i的变化得分三种情况，i + 1、i - 1和j ，任何情况都可能是最快的
            count++//表示每次记一步
            // 思路转变：
            // 其实可能是我想太复杂，我就按照我自己的思想来走
            // 首先扫一下整个数组，看最远的处有没有相等的，即j，如果有就移动，否则让i++
            for (var j = len - 1; j > i; j--) {//从最后开始比
                //需要同时满足两个数相等，且不是同一个数  
                if (arr[i] == arr[j] && i == j) {
                    i = j
                    break
                } else {
                    i++
                    break
                }
                //往回走我觉得还用来干扰我的，所以先不考虑
            }
        }
        return count
    };
};
```